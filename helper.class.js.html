<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: helper.class.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="Tvx_qFwvtk4-uzyRLbvX_"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-authentication.html">authentication</a></div><div class="sidebar-section-children"><a href="module-loadSchemas.html">loadSchemas</a></div><div class="sidebar-section-children"><a href="module-model_mongodb.html">model/mongodb</a></div><div class="sidebar-section-children"><a href="module-model_sqlite.html">model/sqlite</a></div><div class="sidebar-section-children"><a href="module-route_builder.html">route/builder</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="Eh7vKNm50YHXQnftxtGCE"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Api.html">Api</a></div><div class="sidebar-section-children"><a href="Cache.html">Cache</a></div><div class="sidebar-section-children"><a href="Database.html">Database</a></div><div class="sidebar-section-children"><a href="DatabaseBuilder.html">DatabaseBuilder</a></div><div class="sidebar-section-children"><a href="Helper.html">Helper</a></div><div class="sidebar-section-children"><a href="MongoDatabase.html">MongoDatabase</a></div><div class="sidebar-section-children"><a href="SQLiteDatabase.html">SQLiteDatabase</a></div><div class="sidebar-section-children"><a href="Test.html">Test</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">helper.class.js</h1></header><article><pre class="prettyprint source lang-js"><code>import {stat, mkdirSync, readFileSync, readdirSync, readSync, openSync, closeSync, rmSync} from 'fs'
import https from 'https'
import http from 'http'
import moment from 'moment'
import jsonwebtoken from 'jsonwebtoken'
import {fileURLToPath} from 'url'
import path from 'path'
import SHA256 from 'crypto-js/sha256.js'
import {Op} from 'sequelize'
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
/**
 * Helper class
 *
 * @class Helper
 * @classdesc Collection of helper functions and constants.
 */
export default class Helper {
  static IS_SQL = Symbol('IS_SQL')
  static IS_NOT_SQL = Symbol('IS_NOT_SQL')
  static IS_MIDDLEWARE = Symbol('IS_MIDDLEWARE')
  static IS_NOT_MIDDLEWARE = Symbol('IS_NOT_MIDDLEWARE')
  static REQUIRES_CONDITION = Symbol('REQUIRES_CONDITION')
  static REQUIRES_NO_CONDITION = Symbol('REQUIRES_NO_CONDITION')
  static DATABASE_TYPE_SQLITE = Symbol('DATABASE_TYPE_SQLITE')
  static DATABASE_TYPE_MONGODB = Symbol('DATABASE_TYPE_MONGODB')
  static FILE_NAME_AS_KEY = Symbol('FILE_NAME_AS_KEY')
  static FILE_PATH_AS_KEY = Symbol('FILE_PATH_AS_KEY')
  static REPLACE_KEY = Symbol('REPLACE_KEY')
  static REPLACE_VALUE = Symbol('REPLACE_VALUE')
  static SHUTDOWN_SERVER = Symbol('SHUTDOWN_SERVER')
  static DONT_SHUTDOWN_SERVER = Symbol('DONT_SHUTDOWN_SERVER')
  static IS_FAILURE_TEST = Symbol('IS_FAILURE_TEST')
  static IS_SUCCESS_TEST = Symbol('IS_SUCCESS_TEST')
  static DROP_TEST_DATABASE = Symbol('DROP_TEST_DATABASE')
  static DONT_DROP_TEST_DATABASE = Symbol('DONT_DROP_TEST_DATABASE')
  static MATCH_NONE = Symbol('MATCH_NONE')
  static MATCH_KEY = Symbol('MATCH_KEY')
  static MATCH_VALUE = Symbol('MATCH_VALUE')
  static MATCH_BOTH = Symbol('MATCH_BOTH')
  static RECURSIVELY = Symbol('RECURSIVELY')
  static NOT_RECURSIVELY = Symbol('NOT_RECURSIVELY')

  /**
   * Default token validity period in minutes.
   *
   * @memberof Helper
   * @type {Number}
   * @const
   */
  static defaultExpireToken = 3

  /**
   * Default refresh token validity period in minutes.
   *
   * @memberof Helper
   * @type {Number}
   * @const
   */
  static defaultExpireRefresh = 5

  /**
   * Get absolute path of file reletive to this file.
   *
   * @memberof Helper
   * @function getAbsolutePath
   * @param {String} filePath - relative path to file.
   * @returns {String}
   */
  static getAbsolutePath = filePath => path.join(__dirname, filePath)

  /**
   * Get file stats
   *
   * @memberof Helper
   * @function fileStat
   * @param {String} filePath - absolute path to file.
   * @returns {Promise&lt;Object>}
   */
  static fileStat = filePath => {
    return new Promise(resolve => {
      stat(filePath, (error, stats) => {
        if (error) {
          resolve({})
        }
        resolve(stats)
      })
    })
  }

  /**
   * Determine if file exists
   *
   * @memberof Helper
   * @async
   * @function fileExists
   * @param {String} filePath - absolute path to file.
   * @returns {Promise&lt;Boolean>}
   */
  static fileExists = async filePath => {
    const stats = await Helper.fileStat(filePath)
    return stats.size &amp;&amp; stats.size > 0
  }

  /**
   * Determine if directory exists
   *
   * @memberof Helper
   * @async
   * @function directoryExists
   * @param {String} directoryPath - absolute path to directory.
   * @returns {Promise&lt;Boolean>}
   */
  static directoryExists = async directoryPath => {
    const stats = await Helper.fileStat(directoryPath)
    return stats.isDirectory &amp;&amp; stats.isDirectory()
  }

  /**
   * Delete a file
   *
   * @memberof Helper
   * @async
   * @function deleteFile
   * @param {String} path - absolute path to file.
   * @returns {Promise&lt;Boolean>}
   */
  static deleteFile = async path => {
    rmSync(path)
    return await Helper.fileExists(path)
  }

  /**
   * Instantiate an https agent
   *
   * @memberof Helper
   * @function httpsAgent
   * @param {String} certificatePath - absolute path to ssl certificate.
   * @returns {Object}
   */
  static httpsAgent = certificatePath => {
    if (certificatePath) {
      return new https.Agent({
        requestCert: true,
        rejectUnauthorized: false,
        cert: certificatePath
      })
    }

    return null
  }

  /**
   * Generate JWT
   *
   * @memberof Helper
   * @function generateToken
   * @param {Object} payload - a object to encrypt.
   * @param {String} secret - the key used to encrypt the payload.
   * @param {Number} [expireToken] - token validity period in minutes.
   * @param {Number} [expireRefresh] - refresh token validity period in minutes.
   * @returns {Object}
   */
  static generateToken = (
    payload,
    secret,
    expireToken = Helper.defaultExpireToken,
    expireRefresh = Helper.defaultExpireRefresh
  ) => {
    const expiresAfter = moment().add(expireToken, 'minutes')
    const expiresIn = parseInt((expiresAfter - moment()) / 1000)
    const token = jsonwebtoken.sign(payload, secret, {expiresIn})

    const refreshTokenExpiresAfter = moment().add(expireRefresh, 'minutes')
    const refreshTokenExpiresIn = parseInt((refreshTokenExpiresAfter - moment()) / 1000)
    const refreshToken = jsonwebtoken.sign(payload, secret, {
      expiresIn: refreshTokenExpiresIn
    })

    return {token, expiresAfter, refreshToken, refreshTokenExpiresAfter}
  }

  /**
   * verify JWT
   *
   * @memberof Helper
   * @function verifyToken
   * @param {Object} token - the JWT to verify.
   * @param {String} secret - the key used to decrypt the JWT data.
   * @returns {Object}
   */
  static verifyToken = (token, secret) => {
    try {
      return jsonwebtoken.verify(token, secret)
    } catch (error) {
      Helper.errorPrinter(`verifyToken: ${error}`)
      return null
    }
  }

  /**
   * Creates a directory recursively, creating
   * parent directories if they do not exist
   *
   * @memberof Helper
   * @function mkdir
   * @param {Srting} path - absolute path to directory.
   */
  static mkdir = path => {
    try {
      mkdirSync(path, {recursive: true})
    } catch (error) {
      Helper.errorPrinter(`mkdir: ${error}`)
    }
  }

  /**
   * Opens a JSON file and parses string to JS
   *
   * @memberof Helper
   * @function readJsonFile
   * @param {Srting} path - absolute path to file.
   * @returns {Object|Array}
   */
  static readJsonFile = path => {
    try {
      const json = readFileSync(path, 'utf8')
      return JSON.parse(json)
    } catch (error) {
      Helper.errorPrinter(`readJsonFile: ${error}`)
      return {}
    }
  }

  /**
   * Opens a file and reads a number of bytes
   *
   * @memberof Helper
   * @function peekIntoFile
   * @param {Srting} path - absolute path to file.
   * @param {Number} [readNumberOfBytes] - number of bytes to read.
   * @returns {String}
   */
  static peekIntoFile = (path, readNumberOfBytes = 1) => {
    const fd = openSync(path, 'r')
    const buffer = Buffer.alloc(readNumberOfBytes)
    readSync(fd, buffer, 0, readNumberOfBytes, null)
    closeSync(fd)
    return buffer.toString('utf8', 0, readNumberOfBytes)
  }

  /**
   * Opens a JSON file and reads a number of bytes to determine
   * if the JSON data is an array.
   *
   * @memberof Helper
   * @function isJsonArrayFile
   * @param {Srting} path - absolute path to JSON file.
   * @returns {Boolean}
   */
  static isJsonArrayFile = path => {
    const data = Helper.peekIntoFile(path)
    return data.trim().substring(0, 1) === '['
  }

  /**
   * Generate random number
   *
   * @memberof Helper
   * @function randomSingleDigit
   * @returns {Number}
   */
  static randomSingleDigit = () => Math.floor(Math.random() * Math.floor(10))

  /**
   * Generate random string of numbers
   *
   * @memberof Helper
   * @function generateOTP
   * @param {Number} [length] - maximum length of random string.
   * @returns {String}
   */
  static generateOTP = (length = 5) => {
    const randomArray = Buffer.allocUnsafe(length)
      .toString('utf8', 0, length + 1)
      .split('')
    return randomArray.map(() => Helper.randomSingleDigit()).join('')
  }

  /**
   * Internal stdout development environment printer
   *
   * @memberof Helper
   * @function developerPrinter
   * @param {Any} data - warning message.
   */
  static developerPrinter = data => {
    const {NODE_ENV = 'development', DEBUG = false} = process.env
    if (NODE_ENV === 'development' || DEBUG) {
      console.info('\x1b[46m%s\x1b[0m', ' - INFO START ')
      console.info('\x1b[32m%s\x1b[0m', data)
      console.info('\x1b[46m%s\x1b[0m', ' - INFO END ')
    }
  }

  /**
   * Internal stdout warning printer
   *
   * @memberof Helper
   * @function warningPrinter
   * @param {String} data - warning message.
   */
  static warningPrinter = data => {
    const {NODE_ENV = 'development', PRINT_WARNINGS = false} = process.env
    if (NODE_ENV === 'development' || PRINT_WARNINGS) {
      console.info('\x1b[43m%s\x1b[0m', 'WARNING', data)
    }
  }

  /**
   * Internal stdout error printer
   *
   * @memberof Helper
   * @function errorPrinter
   * @param {String} data - error message.
   */
  static errorPrinter = data => {
    const {NODE_ENV = 'development', PRINT_ERRORS = false} = process.env
    if (NODE_ENV === 'development' || PRINT_ERRORS) {
      console.info('\x1b[41m%s\x1b[0m', 'ERROR', data)
    }
  }

  /**
   * Hash a string value
   *
   * @memberof Helper
   * @function hash
   * @param {String} value - string to hash.
   * @returns {String}
   */
  static hash = value => SHA256(value).toString()

  /**
   * Determine whether one string is equal to another when hashed
   *
   * @memberof Helper
   * @function isSameHashed
   * @param {String} plainText - plain text string.
   * @param {String} hashedValue - hashed string.
   * @returns {Boolean}
   */
  static isSameHashed = (plainText, hashedValue) => Helper.hash(`${plainText}`) === `${hashedValue}`

  /**
   * Replace a mongoose operator with sequelize operator
   *
   * @memberof Helper
   * @function sequelizeOpKeys
   * @param {String} key - A mongoose operator.
   * @returns {Symbol}
   */
  static sequelizeOpKeys = key => {
    const keys = {
      // Comparison
      $eq: Op.eq,
      $ne: Op.ne,
      $gt: Op.gt,
      $gte: Op.gte,
      $in: Op.in,
      $nin: Op.notIn,
      $lt: Op.lt,
      $lte: Op.lte,
      // Logical
      $and: Op.and,
      $not: Op.not,
      $or: Op.or,
      // Evaluation
      $regex: Op.regexp
    }
    const incompatibleKeys = [
      '$nor',
      '$exists',
      '$type',
      '$expr',
      '$jsonSchema',
      '$mod',
      '$text',
      '$where',
      '$geoIntersects',
      '$geoWithin',
      '$near',
      '$nearSphere',
      '$box',
      '$center',
      '$centerSphere',
      '$geometry',
      '$maxDistance',
      '$minDistance',
      '$polygon',
      '$elemMatch',
      '$size',
      '$bitsAllClear',
      '$bitsAllSet',
      '$bitsAnyClear',
      '$bitsAnySet',
      '$slice',
      '$comment',
      '$rand',
      '$natural',
      '$currentDate',
      '$inc',
      '$min',
      '$max',
      '$mul',
      '$rename',
      '$set',
      '$setOnInsert',
      '$unset',
      '$addToSet',
      '$pop',
      '$pull',
      '$push',
      '$pullAll',
      '$each',
      '$position',
      '$slice',
      '$sort',
      '$bit'
    ]
    if (incompatibleKeys.includes(key) || key.includes('.$')) {
      throw Error(`This operator is not compatible with SQL: ${key}`)
    }
    if (Object.prototype.hasOwnProperty.call(keys, key)) {
      return keys[key]
    }
    return key
  }

  /**
   * Replace a key or value within an object
   *
   * @memberof Helper
   * @function replaceInObject
   * @param {Object} object - the object.
   * @param {Function} replacerFunction - the function used to replace the key or value.
   * @param {Symbol} [replaceWhat] - the symbol specifying key or value.
   * @param {Boolean} [replaceObjects] - whether to replace object type as well.
   * @returns {Object}
   */
  static replaceInObject = (
    object,
    replacerFunction,
    replaceWhat = Helper.REPLACE_KEY,
    replaceObjects = false
  ) => {
    if (object !== null &amp;&amp; object !== undefined) {
      if (Array.isArray(object)) {
        return object.map(value =>
          Helper.replaceInObject(value, replacerFunction, replaceWhat, replaceObjects)
        )
      }
      if (typeof object === 'object' &amp;&amp; Object.keys(object).length > 0) {
        return Object.keys(object).reduce((builtObject, key) => {
          let value = object[key]
          if (replaceObjects) {
            value = replacerFunction(key, value)
          }
          if (typeof value === 'object') {
            value = Helper.replaceInObject(value, replacerFunction, replaceWhat, replaceObjects)
          }
          const newKey =
            !replaceObjects &amp;&amp; replaceWhat === Helper.REPLACE_KEY ? replacerFunction(key) : key
          const newValue =
            !replaceObjects &amp;&amp; replaceWhat === Helper.REPLACE_VALUE
              ? replacerFunction(value)
              : value
          return {
            ...builtObject,
            [newKey]: newValue
          }
        }, {})
      }
    }
    return object
  }

  /**
   * Populate a key or value within an object
   *
   * @memberof Helper
   * @function populateObject
   * @param {Object} object - the object.
   * @param {Object} [defaults] - a template of the object with default values.
   * @returns {Object}
   */
  static populateObject = (object, defaults) => {
    if (object !== null &amp;&amp; object !== undefined) {
      if (Array.isArray(object)) {
        return object.map(value => Helper.populateObject(value, defaults[0]))
      }
      if (typeof object === 'object') {
        return Object.keys(object).reduce((builtObject, key) => {
          let value = object[key]
          if (typeof value === 'object' &amp;&amp; value !== [] &amp;&amp; value !== {}) {
            value = Helper.populateObject(value, defaults[key])
          } else if (Helper.isEmpty(value)) {
            return builtObject
          }
          return {
            ...builtObject,
            [key]: value
          }
        }, defaults)
      }
    }
    return object
  }

  /**
   * Check if value is empty
   *
   * @memberof Helper
   * @function isEmpty
   * @param {any} element - The value to test.
   * @returns {boolean}
   */
  static isEmpty = element => {
    if (typeof element === 'string') {
      return element.trim().length === 0
    }
    if (Array.isArray(element)) {
      return element.length === 0
    }
    if (typeof element === 'object' &amp;&amp; element !== null) {
      return Object.keys(element).length === 0
    }
    if (element === null || element === undefined) {
      return true
    }
    return false
  }

  /**
   * Format a database query condition object for safe usage if required.
   *
   * @memberof Helper
   * @function gaurdedCondition
   * @param {object|null|undefined} [data] - Query condition.
   * @param {symbol} [isSql] - Whether used on SQL database.
   * @param {symbol} [requiresCondition] - Whether condition is required for safe operation.
   * @returns {object}
   */
  static gaurdedCondition = (
    data,
    isSql = Helper.IS_NOT_SQL,
    requiresCondition = Helper.REQUIRES_NO_CONDITION
  ) => {
    const hasNoConditions =
      !data || (data &amp;&amp; typeof data === 'object' &amp;&amp; Object.keys(data).length === 0)
    if (requiresCondition === Helper.REQUIRES_CONDITION &amp;&amp; hasNoConditions) {
      return false
    }
    let where = isSql === Helper.IS_SQL ? {} : data
    if (data &amp;&amp; isSql === Helper.IS_SQL) {
      where = {where: Helper.replaceInObject(data, Helper.sequelizeOpKeys)}
    }
    return where
  }

  /**
   * Sets KoaRouter response body
   *
   * @memberof Helper
   * @function formatedResponse
   * @param {Any} data - Response body.
   * @returns {String}
   */
  static formatedResponse = data =>
    JSON.stringify({
      tag: moment().valueOf(),
      data
    })

  /**
   * Sets KoaRouter middleware or controller response
   *
   * @memberof Helper
   * @async
   * @function middlewareHandler
   * @param {Object} ctx - KoaRouter controller object.
   * @param {Function} next - KoaRouter next function.
   * @param {Number} [status] - KoaRouter response status.
   * @param {Any} [body] - KoaRouter response body.
   * @param {Symbol} [handlerType] - set whether this function behaves like middleware or a controller.
   */
  static middlewareHandler = async (
    ctx = {},
    next,
    status = 200,
    body,
    handlerType = Helper.IS_NOT_MIDDLEWARE
  ) => {
    ctx.status = status
    if (body) {
      ctx.body = ctx.helper.formatedResponse(body)
    }
    if (handlerType === Helper.IS_MIDDLEWARE &amp;&amp; typeof next === 'function') {
      await next()
    }
  }

  /**
   * Default private encryption key.
   *
   * @memberof Helper
   * @type {String}
   * @const
   */
  static defaultKey = 'ba21767ae494afe5a2165dcb3338c5323e9907050e34542c405d575cc31bf527'

  /**
   * Default configuration object.
   *
   * @memberof Helper
   * @type {Object}
   * @const
   */
  static defaultConfig = {
    database: {
      type: Helper.DATABASE_TYPE_SQLITE, // currently only MongoDB and SQLite type
      databaseFile: undefined, // if SQLite, creates file in project's root directory if undefined
      memoryOnly: false, // SQLite only
      defaultUser: {
        username: 'superuser',
        password: 'superpassword'
      },
      connectionString: undefined, // MongoDB Only
      connectionOptions: {autoIndex: false}, // MongoDB Only
      userDataModelPath: undefined, // Absolute path to user-defined models
      initialiseUserAccount: false,
      /*
      create default database data for user authentication. If true, this will create
      default user (at defaultUser property) and otp database tables/collections 
      for use with the default authentication routes
      */
      addConnection: false
      /*
      when creating the database class make this a seperate
      database connection to the server's
      */
    },
    server: {
      sessionKey: Helper.defaultKey, // server token encryption hash
      formatedResponse: Helper.formatedResponse, // a function that formats the http response data
      httpsConfig: {
        key: undefined, // fs.readFileSync('/app/server-private-key.pem'),
        cert: undefined // fs.readFileSync('/app/server-certificate.pem')
      },
      uploadDir: '/tmp/dump',
      allowCors: false,
      port: 8000,
      proxy: undefined,
      morgan: ['common'],
      userRoutePath: undefined // Absolute path to user-defined routes (see docs for more details)
    },
    service: {
      otp: otp => Helper.developerPrinter({otp}) // a function for sending the otp code. arguments = (otp, databaseObject) (see docs for example)
    },
    account: {
      secretKey: Helper.defaultKey, // encrypting JWT
      usernameField: 'username', // the formfield when logging in (see docs for example)
      jwtExpiresInMinutes: Helper.defaultExpireToken, // 3 minutes
      jwtRefreshExpiresInMinutes: Helper.defaultExpireRefresh // 5 minutes
    },
    system: {
      developerPrinter: Helper.developerPrinter // a function that prints to STDOUT in dev enironment or debug mode (see docs for example)
    },
    test: {
      shutdown: false, // exit the running server after testing completes
      dropDatabase: false // drop the test database
    }
  }

  /**
   * Configuration warning message object.
   *
   * @memberof Helper
   * @type {Object}
   * @const
   */
  static configWarnings = {
    account: {
      secretKey: {
        message:
          '"account.secretKey" is set to the default value that is known all. Please change when deploying to production.',
        response: value => value === Helper.defaultKey
      }
    },
    server: {
      sessionKey: {
        message:
          '"server.sessionKey" is set to the default value that is known all. Please change when deploying to production.',
        response: value => value === Helper.defaultKey
      }
    }
  }

  /**
   * Set config object for a part of the app,
   * populating it with default values where absent.
   *
   * @memberof Helper
   * @function generateConfig
   * @param {String} key - key for the config section to be populated.
   * @param {Object} config - config object defined by the user.
   * @returns {Object}
   */
  static generateConfig = (key, config) => {
    const configured = Object.keys(config).reduce((cfg, currentKey) => {
      let currentCfg = config[currentKey]
      if (typeof currentCfg === 'object' &amp;&amp; !Array.isArray(currentCfg) &amp;&amp; currentCfg !== null) {
        currentCfg = {
          ...cfg[currentKey],
          ...currentCfg
        }
      }
      return {
        ...cfg,
        [currentKey]: currentCfg
      }
    }, Helper.defaultConfig[key])

    if (Object.prototype.hasOwnProperty.call(Helper.configWarnings, key)) {
      const configMessages = Helper.configWarnings[key]
      Object.keys(configMessages).forEach(configKey => {
        const {message, response} = configMessages[configKey]
        if (response(configured[configKey])) {
          Helper.warningPrinter(message)
        }
      })
    }

    return configured
  }

  /**
   * Set config object for the different parts of the app.
   *
   * @memberof Helper
   * @function setConfig
   * @param {Object} [config] - config object defined by the user.
   * @returns {Object}
   */
  static setConfig = (config = {}) => {
    const {database = {}, server = {}, service = {}, account = {}, system = {}, test = {}} = config
    return {
      database: Helper.generateConfig('database', database),
      server: Helper.generateConfig('server', server),
      service: Helper.generateConfig('service', service),
      account: Helper.generateConfig('account', account),
      system: Helper.generateConfig('system', system),
      test: Helper.generateConfig('test', test)
    }
  }

  /**
   * Create an array of absolute file paths.
   *
   * @memberof Helper
   * @function createFileList
   * @param {String} directoryPath - The absolute path to directory.
   * @param {Array} extensions - An array will file extensions to include. Empty array includes all.
   * @param {Object} list - An exting list object to concatenate.
   * @returns {Object}
   */
  static createFileList = (
    directoryPath,
    extensions = [],
    keyValue = Helper.FILE_NAME_AS_KEY,
    list = {}
  ) => {
    const fileList = {...list}
    readdirSync(directoryPath).forEach(file => {
      const includeAll = extensions.length === 0
      const extensionName = path.extname(file).toLowerCase()
      if (includeAll || extensions.includes(extensionName)) {
        const name = path.basename(file, extensionName)
        const filePath = `${directoryPath}/${file}`
        const key = keyValue === Helper.FILE_NAME_AS_KEY ? name : filePath
        if (!Object.prototype.hasOwnProperty.call(fileList, name)) {
          fileList[key] = filePath
        }
      }
    })
    return fileList
  }

  /**
   * An http client.
   * 
   * Params should be in the following order:
   * url, payload, options
   * unless http method is 'any', then: method, url, payload, options
   * 
   * url is only optional without payload
   * payload and options is always optional
   *
   * @name httpClient
   * @memberof Helper
   * @type {Object}
   * @const
   */
  static httpClient = {
    get: (...params) => Helper.httpAction('get', ...params),
    head: (...params) => Helper.httpAction('head', ...params),
    post: (...params) => Helper.httpAction('post', ...params),
    put: (...params) => Helper.httpAction('put', ...params),
    delete: (...params) => Helper.httpAction('delete', ...params),
    connect: (...params) => Helper.httpAction('connect', ...params),
    options: (...params) => Helper.httpAction('options', ...params),
    trace: (...params) => Helper.httpAction('trace', ...params),
    patch: (...params) => Helper.httpAction('patch', ...params),
    any: (...params) => Helper.httpAction('any', ...params)
  }

  /**
   * the http action.
   * Params should be in the following order:
   * action, url, payload, options
   * unless action is 'any', then: action, method, url, payload, options
   * 
   * url is only optional without payload: action, options
   * payload and options is always optional
   *
   * @memberof httpClient
   * @async
   * @function httpAction
   * @param {String} action - represents the http method/verb.
   * @param {String} [method] - Provide the http method if using 'any'.
   * @param {String} [url] - An absolute url.
   * @param {String} [payload] - The request body.
   * @param {Object} [options] - nodejs http|https request options object.
   * @returns {Promise&lt;Object|String>}
   */
  static httpAction = (action, ...params) => {
    return new Promise(resolve => {
      let url, payload, options, responseType
      if (params.length === 0 || action.toLowerCase() === 'any' &amp;&amp; params.length &lt; 2) {
        Helper.errorPrinter('No Parameters passed or Too few parameters passed to Any')
        resolve(null)
        return
      }

      const [param1, param2, param3] = params

      let method
      if (action.toLowerCase() === 'any') {
        method = param1
        url = typeof param2 === 'string' || param3 !== undefined ? param2 : url
        options = typeof param2 === 'object' &amp;&amp; !param3 ? param2 : param3
      } else {
        method = action
        url = typeof param1 === 'string' ? param1 : undefined
        payload = typeof param2 === 'string' ? param2 : undefined
        options = typeof param1 === 'object' ? param1 : typeof param2 === 'object' ? param2 : param3
      }
      if (options) {
        responseType = options.responseType
      }
      Helper.httpRequest({
        url,
        payload,
        method: typeof method === 'string' ? method.toUpperCase() : undefined,
        ...options
      })
      .then(({responseBuffer, originalResponse}) => {     
        if (responseType &amp;&amp; responseType === 'json') {
          const json = JSON.parse(responseBuffer.toString())
          resolve(json)
        } else if (responseType &amp;&amp; responseType === 'string') {
          resolve(responseBuffer.toString())
        } else {
          resolve({responseBuffer, originalResponse})
        }
      })
      .catch(err => {
        Helper.errorPrinter(err)
        resolve(null)
      })
    })
  }

  /**
   * http request.
   *
   * @memberof Helper
   * @async
   * @function httpRequest
   * @param {Object} [options] - Request options
   * @returns {Promise&lt;Object>}
   */
  static httpRequest = (options = {}) => {
    return new Promise((resolve, reject) => {
      const {
        method: methodName,
        hostname: hostName,
        path: pathName,
        url,
        protocol: protocolName = 'http',
        payload = undefined,
        ...remainingOptions
      } = options
      if (typeof methodName !== 'string' || methodName.length &lt; 3) {
        reject({errorMessage: `Method: ${methodName} must be a string and at least 3 characters long`, cause: methodName})
      }

      let requestFunction = protocolName === 'http' ? http : https
      let path = pathName
      let hostname = hostName
      if (typeof url === 'string' &amp;&amp; url.length > 0) {
        const protocolRegex = /^((https|http)(:\/\/)|)([a-z0-9-.@:]+)(\?|\/|#|)(.*)/i
        const protocolMatch = url.match(protocolRegex)
        if (protocolMatch !== null) {
          const [_fullMatch, _scheme, protocolString, _colon, hostString, delimeter, pathString] =
          protocolMatch
          requestFunction = protocolString === 'http' ? http : https
          path = `${delimeter === '/' ? '' : '/'}${delimeter}${pathString}`
          hostname = hostString
        }
      }

      const method = methodName.toUpperCase()
      const request = requestFunction.request({
        method,
        hostname,
        path,
        ...remainingOptions
      }, originalResponse => {
        const {statusCode, statusMessage} = originalResponse
        
        if (statusCode >= 400) {
          reject({errorMessage: statusMessage, cause: statusCode})
        } else {
          let chunks = []

          originalResponse.on('data', chunk => {
            chunks = [...chunks, chunk]
          })

          originalResponse.on('end', () => {
            const responseBuffer = Buffer.concat(chunks)
            resolve({responseBuffer, originalResponse})
          })

          originalResponse.on('error', error => {
            reject({errorMessage: 'httpRequest Response Error', cause: error})
          })
        }
      })

      request.on('error', error => {
        reject({errorMessage: 'httpRequest Request Error', cause: error})
      });

      if (
        typeof payload === 'string' &amp;&amp;
        payload.length > 0 &amp;&amp;
        (method === 'POST' || method === 'PUT' || method === 'PATCH')
      ) {
        request.write(payload)
      }
      request.end()
    })
  }

  /**
   * Compare two objects to determine if both have the same keys.
   *
   * @memberof Helper
   * @function hasAllKeys
   * @param {Object} a - The left comparison object.
   * @param {Object} b - The right comparison object.
   * @param {Symbol} [recursively] - compare keys recursively.
   * @param {Symbol} [matchOn] - how to match the two data types.
   * @returns {Boolean}
   */
  static hasAllKeys = (a, b, recursively = Helper.NOT_RECURSIVELY, matchOn = Helper.MATCH_KEY) => {
    if (!a || !b) {
      return false
    }
    if (matchOn === Helper.MATCH_VALUE) {
      return a === b
    }
    if (Array.isArray(a)) {
      if (a.length !== b.length) {
        return false
      }
      const hasAllKeysFiltered = a.filter((currentA, index) =>
        Helper.hasAllKeys(currentA, b[index], recursively, matchOn)
      )
      return hasAllKeysFiltered.length === a.length
    }
    return Object.keys(a).every(key => {
      if (!Object.keys(b).includes(key)) {
        return false
      }
      const matchNonObject = matchOn === Helper.MATCH_BOTH &amp;&amp; typeof a[key] !== 'object'
      const matchNull = matchOn === Helper.MATCH_BOTH &amp;&amp; a[key] === null
      let bValue = b[key]
      if (typeof bValue !== typeof a[key]) {
        if (bValue instanceof Date) {
          bValue = bValue.toISOString()
        } else {
          bValue = `${bValue}`
        }
      }
      if ((matchNonObject || matchNull) &amp;&amp; a[key] !== bValue) {
        return false
      }
      if (recursively === Helper.NOT_RECURSIVELY || a[key] === null || typeof a[key] !== 'object') {
        return true
      }
      return Helper.hasAllKeys(a[key], b[key], recursively, matchOn)
    })
  }

  /**
   * Get the match Symbol for the passed string value.
   *
   * @memberof Helper
   * @function getMatchSymbol
   * @param {String} matchName - The string name for the symbol.
   * @returns {Symbol}
   */
  static getMatchSymbol = async matchName => {
    switch (matchName) {
      case 'value':
        return Helper.MATCH_VALUE
      case 'key':
        return Helper.MATCH_KEY
      case 'both':
        return Helper.MATCH_BOTH
      case 'none':
      default:
        return Helper.MATCH_NONE
    }
  }

  /**
   * Test an http method with a certain payload to match a predetermined output.
   *
   * @memberof Helper
   * @async
   * @function testRoute
   * @param {String} method - The http request method.
   * @param {String} url - An absolute url.
   * @param {Object} payload - The request headers and body.
   * @param {Number} expectedStatus - The expected http response code.
   * @param {Object} expectedBody - The expected http response body.
   * @param {Object} expectedBody - The expected http response body.
   * @returns {Promise&lt;Object>}
   */
  static testRoute = async (
    method,
    url,
    payload,
    expectedStatus,
    expectedBody,
    matchResponseOn = Helper.MATCH_NONE
  ) => {
    const response = await Helper.httpClient.any(method, url, {
      data: payload.body,
      headers: payload.headers
    })
    const statusPassed = expectedStatus === response.status
    let bodyPassed = !expectedBody
    const checkResponse = matchResponseOn !== Helper.MATCH_NONE
    if (expectedBody &amp;&amp; checkResponse) {
      bodyPassed = Helper.hasAllKeys(
        expectedBody,
        response.data,
        Helper.RECURSIVELY,
        matchResponseOn
      )
    }
    return {passed: statusPassed &amp;&amp; bodyPassed, response}
  }

  /**
   * Reduce an object to only one level of keys
   *
   * @memberof Helper
   * @function flattenObject
   * @param {Object} object - The object to flatten.
   * @param {Object} [flattenedObject] - The flattened object passed in through recursion.
   * @param {String} [prepend] - The key path to prepend current key.
   * @param {String} [delimeter] - The delimeter to add between keys.
   * @returns {Object}
   */
  static flattenObject = (object, flattenedObject = {}, prepend = '', delimeter = '') => {
    for (const key in object) {
      if (typeof object[key] === 'object') {
        flattenedObject = Helper.flattenObject(
          object[key],
          flattenedObject,
          `${prepend}${key}${delimeter}`,
          delimeter
        )
      } else {
        flattenedObject[`${prepend}${key}`] = object[key]
      }
    }
    return flattenedObject
  }

  /**
   * Replace templated keywords in config
   *
   * @memberof Helper
   * @function testConfigReplacer
   * @param {String|Any} value - The value to replace.
   * @param {Object} store - The object to get the replacement value from.
   * @returns {String|Any}
   */
  static testConfigReplacer = (value, store) => {
    if (typeof value === 'string') {
      const regexCache = /\[\$cache\$(.*?)\]/
      const cacheMatch = value.match(regexCache)
      if (cacheMatch) {
        const eventKey = cacheMatch[1]
        return value.replace(regexCache, store[eventKey])
      }
      const regexFunction = /\[\$function\$(.*?)\$(.*?)\]/
      const functionMatch = value.match(regexFunction)
      if (functionMatch) {
        const functionName = functionMatch[1]
        const functionParam = functionMatch[2].split('$')
        return Helper[functionName](...functionParam)
      }
    }
    return value
  }

  /**
   * Test a certain database operation with a certain payload to match a predetermined output.
   *
   * @memberof Helper
   * @async
   * @function testDatabase
   * @param {Function} operation - The database operation.
   * @param {Array} parameters - The parameters passed to the operation.
   * @param {Any} expectedOutput - The expected response from the operation.
   * @returns {Promise&lt;Object>}
   */
  static testDatabase = async (
    operation,
    parameters,
    expectedOutput,
    matchResponseOn = Helper.MATCH_NONE
  ) => {
    const response = await operation(...parameters)
    const typeOfPassed = typeof response === typeof expectedOutput
    const matchResponse = matchResponseOn !== Helper.MATCH_NONE
    let passed = typeOfPassed &amp;&amp; (response === expectedOutput || !matchResponse)

    if (typeof response === 'object' &amp;&amp; matchResponse) {
      passed = Helper.hasAllKeys(expectedOutput, response, Helper.RECURSIVELY, matchResponseOn)
    }
    return {passed, response}
  }

  /**
   * Convert a string to camel case
   *
   * @memberof Helper
   * @function toCamelcase
   * @param {String} text - The string to convert.
   * @param {String} delimeter - The character used to split the word.
   * @returns {String}
   */
  static toCamelcase = (text, delimeter = ' ') => {
    const value = text.toLowerCase()
    if (value.includes(delimeter)) {
      return value
        .split(delimeter)
        .map((word, index) =>
          index > 0 ? `${word.charAt(0).toUpperCase()}${word.substring(1)}` : word
        )
        .join('')
    }
    return value
  }
}
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="Tvx_qFwvtk4-uzyRLbvX_"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-authentication.html">authentication</a></div><div class="sidebar-section-children"><a href="module-loadSchemas.html">loadSchemas</a></div><div class="sidebar-section-children"><a href="module-model_mongodb.html">model/mongodb</a></div><div class="sidebar-section-children"><a href="module-model_sqlite.html">model/sqlite</a></div><div class="sidebar-section-children"><a href="module-route_builder.html">route/builder</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="Eh7vKNm50YHXQnftxtGCE"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="Api.html">Api</a></div><div class="sidebar-section-children"><a href="Cache.html">Cache</a></div><div class="sidebar-section-children"><a href="Database.html">Database</a></div><div class="sidebar-section-children"><a href="DatabaseBuilder.html">DatabaseBuilder</a></div><div class="sidebar-section-children"><a href="Helper.html">Helper</a></div><div class="sidebar-section-children"><a href="MongoDatabase.html">MongoDatabase</a></div><div class="sidebar-section-children"><a href="SQLiteDatabase.html">SQLiteDatabase</a></div><div class="sidebar-section-children"><a href="Test.html">Test</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>